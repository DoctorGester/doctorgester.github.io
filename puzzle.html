<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Puzzle Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .mode-toggle {
            text-align: center;
            margin-bottom: 20px;
        }

        .mode-toggle button {
            margin: 0 5px;
        }

        .mode-toggle button.active {
            background: #764ba2;
        }

        .rules {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .rules h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .rules ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .game-area {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .board {
            display: inline-block;
            border: 3px solid #333;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .row {
            display: flex;
        }

        .cell {
            width: 70px;
            height: 70px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            user-select: none;
        }

        .cell:hover {
            transform: scale(1.05);
            z-index: 10;
        }

        .cell.attacking {
            box-shadow: inset 0 0 0 4px rgba(255, 0, 0, 0.6);
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        .cell.attacker {
            box-shadow: inset 0 0 0 4px rgba(0, 123, 255, 0.8);
        }

        @keyframes pulse {
            from {
                box-shadow: inset 0 0 0 4px rgba(255, 0, 0, 0.6);
            }
            to {
                box-shadow: inset 0 0 0 4px rgba(255, 0, 0, 0.9);
            }
        }

        .cell.white-square {
            background-color: #f0d9b5;
        }

        .cell.black-square {
            background-color: #b58863;
        }

        .piece {
            font-size: 40px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        .piece.white {
            color: white;
            text-shadow:
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000,
                0 0 3px #000;
        }

        .piece.black {
            color: #1a1a1a;
        }

        .piece.unknown {
            color: #888;
            opacity: 0.5;
        }

        .clues {
            flex: 1;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }

        .clues h3 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .clue-item {
            padding: 8px;
            margin-bottom: 8px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #ddd;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .clue-item.satisfied {
            border-left-color: #28a745;
            background: #d4edda;
        }

        .clue-item.unsatisfied {
            border-left-color: #dc3545;
            background: #f8d7da;
        }

        .clue-item button {
            padding: 4px 8px;
            font-size: 0.8em;
            background: #dc3545;
        }

        .controls {
            margin-top: 30px;
            text-align: center;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 10px;
            transition: background 0.3s;
        }

        button:hover {
            background: #5568d3;
        }

        button:active {
            transform: translateY(1px);
        }

        .message {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            display: none;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            display: block;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            display: block;
        }

        .message.info {
            background: #d1ecf1;
            color: #0c5460;
            display: block;
        }

        .legend {
            margin-top: 20px;
            text-align: center;
            font-size: 0.9em;
            color: #666;
        }

        .editor-section {
            display: none;
            margin-top: 20px;
        }

        .editor-section.active {
            display: block;
        }

        .editor-controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .editor-controls h3 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .piece-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .piece-selector button {
            padding: 10px 20px;
            font-size: 1.2em;
        }

        .piece-selector button.selected {
            background: #764ba2;
            transform: scale(1.1);
        }

        .clue-editor {
            margin-top: 20px;
        }

        .clue-editor input, .clue-editor select {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .clue-editor input[type="number"] {
            width: 80px;
        }

        .share-section {
            margin-top: 20px;
            padding: 15px;
            background: #e7f3ff;
            border-radius: 8px;
        }

        .share-section input {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .play-mode, .edit-mode {
            display: none;
        }

        .play-mode.active, .edit-mode.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Chess Color Puzzle</h1>

        <div class="mode-toggle">
            <button id="play-mode-btn" class="active" onclick="switchMode('play')">Play Mode</button>
            <button id="edit-mode-btn" onclick="switchMode('edit')">Editor Mode</button>
        </div>

        <div class="play-mode active">
            <div class="rules">
                <h3>How to Play:</h3>
                <ul>
                    <li>Click pieces to toggle between Black/White/Unknown</li>
                    <li>Hover over pieces to see their attack patterns</li>
                    <li>Attacks pass through pieces</li>
                    <li>White Pawns attack up, Black Pawns attack down</li>
                    <li>Satisfy all the clues to win!</li>
                </ul>
            </div>
        </div>

        <div class="edit-mode">
            <div class="editor-controls">
                <h3>Board Editor:</h3>
                <p>Select a piece type, then click on the board to place it:</p>
                <div class="piece-selector">
                    <button onclick="selectPiece('K')">♔ King</button>
                    <button onclick="selectPiece('Q')">♕ Queen</button>
                    <button onclick="selectPiece('R')">♖ Rook</button>
                    <button onclick="selectPiece('B')">♗ Bishop</button>
                    <button onclick="selectPiece('N')">♘ Knight</button>
                    <button onclick="selectPiece('P')">♙ Pawn</button>
                </div>
            </div>
        </div>

        <div class="game-area">
            <div id="board" class="board"></div>
            <div class="clues">
                <h3>Clues:</h3>
                <div id="clues-list"></div>
                <div class="edit-mode">
                    <div class="clue-editor">
                        <h4>Add Clue:</h4>
                        <select id="clue-type">
                            <option value="all">Every White piece attacked by White</option>
                            <option value="WK">White Kings attack White pieces</option>
                            <option value="WQ">White Queens attack White pieces</option>
                            <option value="WR">White Rooks attack White pieces</option>
                            <option value="WB">White Bishops attack White pieces</option>
                            <option value="WN">White Knights attack White pieces</option>
                            <option value="WP">White Pawns attack White pieces</option>
                            <option value="BK">Black Kings attack White pieces</option>
                            <option value="BQ">Black Queens attack White pieces</option>
                            <option value="BR">Black Rooks attack White pieces</option>
                            <option value="BB">Black Bishops attack White pieces</option>
                            <option value="BN">Black Knights attack White pieces</option>
                            <option value="BP">Black Pawns attack White pieces</option>
                        </select>
                        <input type="number" id="clue-count" placeholder="Count" min="0" value="1">
                        <button onclick="addClue()">Add Clue</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="play-mode active">
                <button onclick="checkSolution()">Check Solution</button>
                <button onclick="resetBoard()">Reset</button>
            </div>
            <div class="edit-mode">
                <button onclick="generateShareLink()">Generate Shareable Link</button>
                <button onclick="clearBoard()">Clear Board</button>
            </div>
        </div>

        <div id="message" class="message"></div>

        <div class="edit-mode">
            <div class="share-section" id="share-section" style="display: none;">
                <h4>Shareable Link:</h4>
                <input type="text" id="share-link" readonly onclick="this.select()">
                <p style="margin-top: 10px; font-size: 0.9em;">Copy this link to share your puzzle!</p>
            </div>
        </div>

        <div class="legend">
            <strong>Piece Legend:</strong> K=King, Q=Queen, R=Rook, B=Bishop, N=Knight, P=Pawn
        </div>
    </div>

    <script>
        const DEFAULT_SETUP = [
            ['B', 'Q', 'N', 'R'],
            ['N', 'R', 'P', 'N'],
            ['B', 'B', 'K', 'R'],
            ['R', 'P', 'R', 'P'],
            ['B', 'Q', 'K', 'N']
        ];

        const DEFAULT_CLUES = [
            { desc: "Every White piece is attacked by at least 1 White piece", check: checkEveryWhiteAttacked },
            { desc: "White Kings attack White pieces a total of 1 times", type: "white-king", count: 1 },
            { desc: "White Rooks attack White pieces a total of 7 times", type: "white-rook", count: 7 },
            { desc: "White Bishops attack White pieces a total of 1 times", type: "white-bishop", count: 1 },
            { desc: "White Knights attack White pieces a total of 5 times", type: "white-knight", count: 5 },
            { desc: "Black Knights attack White pieces a total of 10 times", type: "black-knight", count: 10 },
            { desc: "White Pawns attack White pieces a total of 5 times", type: "white-pawn", count: 5 }
        ];

        const PIECE_SYMBOLS = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙'
        };

        let SETUP = [];
        let CLUES = [];
        let board = [];
        let currentMode = 'play';
        let selectedPiece = 'K';

        // Parse URL hash on load
        function parseUrlHash() {
            const hash = window.location.hash.substring(1);
            if (!hash) {
                SETUP = JSON.parse(JSON.stringify(DEFAULT_SETUP));
                CLUES = DEFAULT_CLUES.map(clue => {
                    if (clue.check) {
                        return { desc: clue.desc, check: clue.check };
                    } else {
                        return { desc: clue.desc, type: clue.type, count: clue.count };
                    }
                });
                return;
            }

            const params = new URLSearchParams(hash);
            const setupStr = params.get('setup');
            const cluesStr = params.get('clues');

            if (setupStr) {
                SETUP = setupStr.split(',').map(row => row.split(''));
            } else {
                SETUP = JSON.parse(JSON.stringify(DEFAULT_SETUP));
            }

            if (cluesStr) {
                CLUES = cluesStr.split(';').map(clueStr => {
                    if (clueStr === 'all') {
                        return { desc: "Every White piece is attacked by at least 1 White piece", check: checkEveryWhiteAttacked };
                    }
                    const [type, count] = clueStr.split(':');
                    const colorMap = { 'W': 'white', 'B': 'black' };
                    const pieceMap = { 'K': 'king', 'Q': 'queen', 'R': 'rook', 'B': 'bishop', 'N': 'knight', 'P': 'pawn' };
                    const color = colorMap[type[0]];
                    const piece = pieceMap[type[1]];
                    const colorCapital = color.charAt(0).toUpperCase() + color.slice(1);
                    const pieceCapital = piece.charAt(0).toUpperCase() + piece.slice(1) + 's';
                    return {
                        desc: `${colorCapital} ${pieceCapital} attack White pieces a total of ${count} times`,
                        type: `${color}-${piece}`,
                        count: parseInt(count)
                    };
                });
            } else {
                CLUES = DEFAULT_CLUES.map(clue => {
                    if (clue.check) {
                        return { desc: clue.desc, check: clue.check };
                    } else {
                        return { desc: clue.desc, type: clue.type, count: clue.count };
                    }
                });
            }
        }

        function encodePuzzle() {
            const setupStr = SETUP.map(row => row.join('')).join(',');
            const cluesStr = CLUES.map(clue => {
                if (clue.check || !clue.type) return 'all';
                const [color, piece] = clue.type.split('-');
                const colorCode = color[0].toUpperCase();
                const pieceCode = piece[0].toUpperCase();
                return `${colorCode}${pieceCode}:${clue.count}`;
            }).join(';');
            return `setup=${setupStr}&clues=${cluesStr}`;
        }

        function switchMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.play-mode').forEach(el => {
                el.classList.toggle('active', mode === 'play');
            });
            document.querySelectorAll('.edit-mode').forEach(el => {
                el.classList.toggle('active', mode === 'edit');
            });
            document.getElementById('play-mode-btn').classList.toggle('active', mode === 'play');
            document.getElementById('edit-mode-btn').classList.toggle('active', mode === 'edit');

            if (mode === 'edit') {
                renderBoardEditor();
            } else {
                renderBoard();
            }
            renderClues();
        }

        function selectPiece(piece) {
            selectedPiece = piece;
            document.querySelectorAll('.piece-selector button').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        function initBoard() {
            board = SETUP.map((row, r) =>
                row.map((piece, c) => ({
                    type: piece,
                    color: null,
                    row: r,
                    col: c
                }))
            );
            renderBoard();
            renderClues();
        }

        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';

            board.forEach((row, r) => {
                const rowEl = document.createElement('div');
                rowEl.className = 'row';

                row.forEach((cell, c) => {
                    const cellEl = document.createElement('div');
                    const isWhiteSquare = (r + c) % 2 === 0;
                    cellEl.className = `cell ${isWhiteSquare ? 'white-square' : 'black-square'}`;

                    const pieceEl = document.createElement('div');
                    pieceEl.className = `piece ${cell.color || 'unknown'}`;
                    pieceEl.textContent = PIECE_SYMBOLS[cell.type];

                    cellEl.appendChild(pieceEl);
                    cellEl.onclick = () => togglePiece(r, c);
                    cellEl.onmouseenter = () => highlightAttacks(r, c);
                    cellEl.onmouseleave = () => clearHighlights();
                    rowEl.appendChild(cellEl);
                });

                boardEl.appendChild(rowEl);
            });
        }

        function renderBoardEditor() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';

            SETUP.forEach((row, r) => {
                const rowEl = document.createElement('div');
                rowEl.className = 'row';

                row.forEach((piece, c) => {
                    const cellEl = document.createElement('div');
                    const isWhiteSquare = (r + c) % 2 === 0;
                    cellEl.className = `cell ${isWhiteSquare ? 'white-square' : 'black-square'}`;

                    const pieceEl = document.createElement('div');
                    pieceEl.className = 'piece';
                    pieceEl.textContent = PIECE_SYMBOLS[piece];

                    cellEl.appendChild(pieceEl);
                    cellEl.onclick = () => setPiece(r, c);
                    rowEl.appendChild(cellEl);
                });

                boardEl.appendChild(rowEl);
            });
        }

        function setPiece(row, col) {
            SETUP[row][col] = selectedPiece;
            renderBoardEditor();
        }

        function togglePiece(row, col) {
            const piece = board[row][col];
            if (piece.color === null) {
                piece.color = 'white';
            } else if (piece.color === 'white') {
                piece.color = 'black';
            } else {
                piece.color = null;
            }
            renderBoard();
            renderClues();
        }

        function highlightAttacks(row, col) {
            if (currentMode === 'edit') return;
            clearHighlights();

            const piece = board[row][col];
            if (!piece.color) return;

            const attacks = getAttackedSquares(piece, row, col);

            const boardEl = document.getElementById('board');
            const rows = boardEl.children;
            const attackerCell = rows[row].children[col];
            attackerCell.classList.add('attacker');

            attacks.forEach(([ar, ac]) => {
                const targetCell = rows[ar].children[ac];
                targetCell.classList.add('attacking');
            });
        }

        function clearHighlights() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.classList.remove('attacking', 'attacker');
            });
        }

        function getAttackedSquares(piece, row, col) {
            const attacks = [];
            const rows = SETUP.length;
            const cols = SETUP[0].length;

            if (piece.type === 'K') {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nr = row + dr;
                        const nc = col + dc;
                        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                            attacks.push([nr, nc]);
                        }
                    }
                }
            } else if (piece.type === 'Q') {
                attacks.push(...getLineAttacks(row, col, [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]));
            } else if (piece.type === 'R') {
                attacks.push(...getLineAttacks(row, col, [[1,0],[-1,0],[0,1],[0,-1]]));
            } else if (piece.type === 'B') {
                attacks.push(...getLineAttacks(row, col, [[1,1],[1,-1],[-1,1],[-1,-1]]));
            } else if (piece.type === 'N') {
                const moves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
                moves.forEach(([dr, dc]) => {
                    const nr = row + dr;
                    const nc = col + dc;
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                        attacks.push([nr, nc]);
                    }
                });
            } else if (piece.type === 'P') {
                const direction = piece.color === 'white' ? -1 : 1;
                [[-1, 1]].forEach(([_, dc]) => {
                    const nr = row + direction;
                    const nc1 = col + dc;
                    const nc2 = col - dc;
                    if (nr >= 0 && nr < rows) {
                        if (nc1 >= 0 && nc1 < cols) attacks.push([nr, nc1]);
                        if (nc2 >= 0 && nc2 < cols) attacks.push([nr, nc2]);
                    }
                });
            }

            return attacks;
        }

        function getLineAttacks(row, col, directions) {
            const attacks = [];
            const rows = SETUP.length;
            const cols = SETUP[0].length;
            directions.forEach(([dr, dc]) => {
                let nr = row + dr;
                let nc = col + dc;
                while (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                    attacks.push([nr, nc]);
                    nr += dr;
                    nc += dc;
                }
            });
            return attacks;
        }

        function countAttacks(attackerType, attackerColor, targetColor) {
            let count = 0;
            board.forEach((row, r) => {
                row.forEach((piece, c) => {
                    if (piece.type === attackerType && piece.color === attackerColor) {
                        const attacks = getAttackedSquares(piece, r, c);
                        attacks.forEach(([ar, ac]) => {
                            if (board[ar][ac].color === targetColor) {
                                count++;
                            }
                        });
                    }
                });
            });
            return count;
        }

        function checkEveryWhiteAttacked() {
            let allAttacked = true;
            board.forEach((row, r) => {
                row.forEach((piece, c) => {
                    if (piece.color === 'white') {
                        let isAttacked = false;
                        board.forEach((row2, r2) => {
                            row2.forEach((attacker, c2) => {
                                if (attacker.color === 'white' && !(r2 === r && c2 === c)) {
                                    const attacks = getAttackedSquares(attacker, r2, c2);
                                    if (attacks.some(([ar, ac]) => ar === r && ac === c)) {
                                        isAttacked = true;
                                    }
                                }
                            });
                        });
                        if (!isAttacked) {
                            allAttacked = false;
                        }
                    }
                });
            });
            return allAttacked;
        }

        function checkClue(clue) {
            if (clue.check) {
                return clue.check();
            }

            const [color, type] = clue.type.split('-');
            const actualCount = countAttacks(type.toUpperCase(), color, 'white');
            return actualCount === clue.count;
        }

        function renderClues() {
            const cluesEl = document.getElementById('clues-list');
            cluesEl.innerHTML = '';

            CLUES.forEach((clue, index) => {
                const clueEl = document.createElement('div');
                clueEl.className = 'clue-item';

                if (currentMode === 'play') {
                    const satisfied = checkClue(clue);
                    if (hasAllColors()) {
                        clueEl.classList.add(satisfied ? 'satisfied' : 'unsatisfied');
                    }
                }

                const textEl = document.createElement('span');
                textEl.textContent = clue.desc;
                clueEl.appendChild(textEl);

                if (currentMode === 'edit') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.onclick = () => deleteClue(index);
                    clueEl.appendChild(deleteBtn);
                }

                cluesEl.appendChild(clueEl);
            });
        }

        function addClue() {
            const type = document.getElementById('clue-type').value;
            const count = parseInt(document.getElementById('clue-count').value);

            if (type === 'all') {
                CLUES.push({ desc: "Every White piece is attacked by at least 1 White piece", check: checkEveryWhiteAttacked });
            } else {
                const colorMap = { 'W': 'White', 'B': 'Black' };
                const pieceMap = { 'K': 'Kings', 'Q': 'Queens', 'R': 'Rooks', 'B': 'Bishops', 'N': 'Knights', 'P': 'Pawns' };
                const color = colorMap[type[0]];
                const piece = pieceMap[type[1]];
                CLUES.push({
                    desc: `${color} ${piece} attack White pieces a total of ${count} times`,
                    type: `${color.toLowerCase()}-${piece.toLowerCase().slice(0, -1)}`,
                    count: count
                });
            }
            renderClues();
        }

        function deleteClue(index) {
            CLUES.splice(index, 1);
            renderClues();
        }

        function hasAllColors() {
            return board.every(row => row.every(cell => cell.color !== null));
        }

        function checkSolution() {
            const messageEl = document.getElementById('message');

            if (!hasAllColors()) {
                messageEl.className = 'message error';
                messageEl.textContent = 'Please assign colors to all pieces first!';
                return;
            }

            const allSatisfied = CLUES.every(checkClue);

            if (allSatisfied) {
                messageEl.className = 'message success';
                messageEl.textContent = 'Congratulations! You solved the puzzle!';
            } else {
                messageEl.className = 'message error';
                messageEl.textContent = 'Not quite right. Check the clues and try again!';
            }

            renderClues();
        }

        function resetBoard() {
            initBoard();
            document.getElementById('message').style.display = 'none';
        }

        function clearBoard() {
            SETUP = SETUP.map(row => row.map(() => 'P'));
            CLUES = [];
            renderBoardEditor();
            renderClues();
        }

        function generateShareLink() {
            const encoded = encodePuzzle();
            const url = window.location.origin + window.location.pathname + '#' + encoded;
            document.getElementById('share-link').value = url;
            document.getElementById('share-section').style.display = 'block';

            const messageEl = document.getElementById('message');
            messageEl.className = 'message info';
            messageEl.textContent = 'Share link generated! Copy the link below to share your puzzle.';
        }

        // Initialize
        parseUrlHash();
        initBoard();
    </script>
</body>
</html>
